---
title: "HW3"
output: html_document
date: "2024-03-05"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message=FALSE}
library(tidyverse) 
```

## 1. Универсальные лингвические иерархии: порядок прилагательных в новогреческом языке (стандартный и кипрский диалекты)  

[Данные](https://raw.githubusercontent.com/olesar/2023dav4compling/main/data/greek-word-order-mono_translit.txt) (социолингвистическая анкета и результаты эксперимента в одном файле) взяты, с адаптацией, из исследования:
Leivada, Evelina; Westergaard, Marit, 2019, [Universal linguistic hierarchies are not innately wired](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6679903/pdf/peerj-07-7438.pdf). PeerJ, v.7.

Источник данных: репозиторий TROLLing:
Leivada, Evelina; Westergaard, Marit, 2019, "Replication Data for: Universal linguistic hierarchies are not innately wired", https://doi.org/10.18710/NTLLUF, DataverseNO, V1

#### Конструкции с двумя прилагательными

В английском языке порядок двух прилагательных в таких фразах, как:
```
 a big black bag # хорошо
*a black big bag # неприемлемо, грамматически неправильно или семантически аномально
```
определяется семантическим классом прилагательного (например, прилагательное «цвета» ближе к существительному, чем прилагательное «размера»).

Синтаксическая иерархия близости к существительному в универсальной грамматике Хомского предполагает следующий порядок, который считается врожденным и универсальным (= действительным для всех языков).

```
Subjective Comment > Evidential > Size > Length
> Height > Speed > Depth > Width > Temperature > Wetness > Age
> Shape > Color > Nationality/Origin > Material 
# (на основе Scott, 2002: 114)
```

Цель исследования Leivada & Westergaard — определить, что происходит, когда люди воспринимают примеры с порядком, который либо соответствует иерархии, либо нарушает ее.

#### Метод

В первом эксперименте 140 нейротипичных взрослых носителей языка выполнили задание с выбором на время (a timed forced choice task), в котором использовались стимулы, представляющие комбинацию двух прилагательных и конкретного существительного (например, *Έπια ένα στενό ισπανικό βρασιόλι.* 'I bought a narrow Spanish bracelet.'). Были собраны данные двух типов:

(i) суждения о приемлемости по 3-балльной шкале Ликерта:
     1. неправильно,
     2. ни правильно, ни неправильно,
     3. правильный;

(ii) время реакции (RT).

В стимулах использовались три условия:  
1. прилагательное размера > прилагательное национальности, 
2. прилагательное цвета > прилагательное формы,  
3. прилагательное субъективного комментария > прилагательное материала. 

Каждое условие предъявлялось в двух вариантах порядка слов. При конгруэнтном порядке расположение пары прилагательных соответствовало тому, что диктует универсальная иерархия. В неконгруэнтном порядке порядок был обратным, поэтому иерархия была нарушена.

Во втором эксперименте 30 билингвов (носителей стандартного и кипрского греческого) были протестированы на обоих диалектах, по 36 наблюдений на участника, по 18 на каждый вариант.

В обоих экспериментах использовались два типа [филлеров] (https://www.hlp.rochester.edu/resources/BCS152-Tutorial/Fillers.html): FillerAcceptable и FillerUnacceptable — предложения, которые включали правильно построенные и неграмматические структуры, соответственно. В обеих задачах соотношение наполнителей к реальным тестовым структурам составляло 2:1. Смотри также [ключи к данным](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6679903/bin/peerj-07-7438-s001.txt).

#### Данные

Загрузите данные из файла в переменную mono, переведя строковые данные в факторы. В переменной mono_socio сохраните данные социолингвистической анкеты. В переменной mono оставьте только данные самого эксперимента. Переименуйте заголовки в последней таблице в следующие: "ParticipantID", "QuestionType", "NQuestions", "Likert", "RT".

```{r}
suppressMessages(library(tidyverse)) 

mono <- read.csv('https://raw.githubusercontent.com/olesar/2023dav4compling/main/data/greek-word-order-mono_translit.txt', head=TRUE, sep=";")

mono_socio <- mono %>%
  filter(type.of.question == "Form")
mono_socio

mono <- mono %>%
  filter(type.of.question != "Form")
mono <- mono[ , !(names(mono) == 'X')] %>%
  rename(ParticipantID = Participant.ID, QuestionType = type.of.question, NQuestions = number.of.question, Likert = response.on.the.acceptability.judgment.scale, RT = reaction.times.in.milliseconds)
mono$RT <- factor(mono$RT)
mono
```

## Описание данных

### 1.1

Взглянем на данные, чтобы ответить на следующие вопросы о социолингвистических характеристиках испытуемых: 

1. Сколько участников указано в датафрейме?

2. Сколько из них женщин и мужчин?

3. Какие уровни образования указаны в датафрейме?

4. Сколько участников каждого уровня образования?

5. Сколько леворуких и праворуких участников?

Напишите код, представляющий ответы на эти вопросы в виде одной или нескольких таблиц. 
Используйте функции из пакета tidyverse: `filter`, `group_by`, `count` and `distinct`. 
(Еще один способ - использовать `pivot_wider`.)

```{r 1.1}
cleaned_mono_socio <- mono_socio %>%
  pivot_wider(names_from=reaction.times.in.milliseconds, values_from=X)
cleaned_mono_socio

print("1. Сколько участников указано в датафрейме?")
n_participants <- cleaned_mono_socio %>%
        distinct(Participant.ID) %>%
        count()%>%
        rename(n_participants = n)
print(n_participants)

print("2. Сколько из них женщин и мужчин?")
n_women <- cleaned_mono_socio %>% 
        filter(sex == "female") %>%
        count() %>%
        rename(n_women = n)
  
n_men <- cleaned_mono_socio %>% 
        filter(sex == "male") %>%
        count() %>%
        rename(n_men = n)
print(n_women)
print(n_men)

print("3. Какие уровни образования указаны в датафрейме?")
education_levels <- cleaned_mono_socio %>%
  distinct(education)
print(education_levels)

print("4. Сколько участников каждого уровня образования?")
counts <- cleaned_mono_socio %>%
        group_by(education) %>%
        count() %>%
        rename(n_participants = n)
print(counts)

print("5. Сколько леворуких и праворуких участников?")
n_left <- cleaned_mono_socio %>% 
        filter(handedness == "left") %>%
        count() %>%
        rename(n_left = n)
  
n_right <- cleaned_mono_socio %>% 
        filter(handedness == "right") %>%
        count() %>%
        rename(n_right = n)
print(n_left)
print(n_right)
```

### 1.2

Постройте график плотности, который показывает распределение RT в эксперименте в целом (для всех участников и условий. Отобразите красным пунктиром линию, показывающую среднее значение RT. 

```{r 1.2}
x <- c(mono$RT)
x <- as.numeric(x)
d <- density(x)
xmean = mean(x)
plot(d)

abline(v=xmean, col="red", lty="dotted")
```

### 1.3

Верно ли, что данные времени реакции нормально распределены? Есть ли в распределении длинные левые или правые хвосты?? 

```
Нет, данные времени реакции распределены не нормально. Наблюдается 2 вершины, и, хотя на графике есть одна крупная вершина, напоминающее нормальное распределение, она не симметрична относительно средней величины (1229.921) и равна приблизительно 700. 

В распределении есть длинный правый хвост. 
```

### 1.4

Преобразуйте данные с помощью функциии логарифма (RTlog = log10(RT)).

```{r 1.4}
RTlog = log10(x)
```

### 1.5

Создайте график, похожий на 1.3, но показывающий логарифимированные значения RT. 

```{r 1.5}
dlog <- density(RTlog)
rtlog_mean = mean(RTlog)
plot(dlog)

abline(v=rtlog_mean, col="red", lty="dotted")
```

### 1.6

Отфильтруйте выбросы:  
* автоматические ответы, время реакции на которые меньше 600 ms (будем полагать, что кнопка была нажата слишком быстро, еще до того, как у участника было достаточно времени рассмотреть показанный ему стимул и принять решение);  
* ответы, в которых RTlog отличается от среднего значения RTlog более, чем на 3 стандартных отклонения (SD);  
* филлеры (как приемлемые, так и неприемлемые).  
Сохраните очищенные от выбросов данные в переменную `mono1`.

```{r 1.6}
mono1 <- mono
mono1$RT <- as.numeric(as.character(mono1$RT))
mono1 <- mono1 %>%
  filter(RT > 600) %>%
  filter(NQuestions < 99)
mono1$RTlog <- log10(mono1$RT)

mean_RTlog <- mean(mono1$RTlog)
sd_RTlog <- sd(mono1$RTlog)

mono1 <- mono1 %>%
  filter(abs(RTlog - mean_RTlog) <= 3 * sd_RTlog)
mono1
```

Воспроизведите графики типа показанных на Рис. 1-7 в статье, используя пакет `ggplot2`. 
Визуально, как по оформлению, так и по отображаемым значениям, они могут отличаться от приведенных в статье (наши данные могут не во всем соответствовать тем, что использовали авторы в статье).  

### 1.7.1

Рисунок 1

```{r 1.7.1}
library(ggplot2)

mono2 <- mono1 %>%
  mutate(order = if_else(NQuestions >= 93, "SubjectiveComment-Material",
                         if_else(NQuestions >= 87, "Shape-Color", 
                                 if_else(NQuestions <= 86, "Size-Nationality", "None"))))
mono2

# Subjective Comment > Evidential > Size > Length
# > Height > Speed > Depth > Width > Temperature > Wetness > Age
# > Shape > Color > Nationality/Origin > Material 

congruent = c(81, 82, 83, 87, 88, 89, 93, 94, 95)
incongruent = c(84, 85, 86, 90, 91, 92, 96, 97, 98)

mono_congruent <- mono2 %>%
  filter(NQuestions %in% congruent)
mono_congruent$type = "Congruent"

mono_incongruent <- mono2 %>%
  filter(NQuestions %in% incongruent)
mono_incongruent$type = "Incongruent"

mono3 <- mono_congruent %>%
  bind_rows(mono_incongruent)


count_func <- function(df, adjs, outcome){
    output <- mono2 %>%
      filter(order == adjs) %>%
      filter(Likert == outcome) %>%
      count() %>%
      pull()
    
    return(output)
}

order <- c("Size-Nationality", "Shape-Color", "SubjectiveComment-Material")
likert <- c("Correct", "Wrong", "Neither correct nor wrong")

values_con <- list()
for (o in order) {
  for (l in likert) {
    values_con <- append(values_con, count_func(mono_congruent, o, l))
  }
}
values_con

values_incon <- list()
for (o in order) {
  for (l in likert) {
    values_incon <- append(values_incon, count_func(mono_incongruent, o, l))
  }
}
values_incon

vals_con <- unlist(values_con)
vals_incon <- unlist(values_incon)

vals <- append(vals_con, vals_incon)

condition <- c(rep("Correct", 6), rep("Wrong", 6), rep("Neither correct nor wrong", 6))
ord <- rep(c("Size-Nationality", "Shape-Color", "SubjectiveComment-Material"), 2)

tasks <- c("Size-Nationality", "Shape-Color", "Subjective Comment-Material")
types <- c("Congruent", "Incongruent")

combinations <- do.call(paste, expand.grid(tasks, tasks))

ord <- c("Size-Nationality", "Shape-Color", "SubjectiveComment-Material")


value <- c(vals)
type <- c(rep("Congruent" , 9) , rep("Incongruent" , 9))
condition <- rep(c("Correct", "Wrong", "Neither correct nor wrong"), 6)
data <- data.frame(type,condition,value,ord)

ggplot(data, aes(fill=condition, y=value, x=ord)) + 
    geom_bar(position="dodge", stat="identity") +
    facet_grid(. ~ type, scales = "free_x", space = "free_x") +
    scale_fill_manual(values = c("gray40", "gray60", "gray80")) +
    theme_minimal() +
    theme(legend.position="bottom") +
    xlab("") + 
    ylab("")

```

### 1.7.2

Рисунок 2

```{r 1.7.2}
Order <- c("Congruent", "Incongruent")

condition <- c("Correct", "Wrong", "Neither correct nor wrong", "Correct", "Wrong", "Neither correct nor wrong")

vals <- append(vals_con, vals_incon)

data <- data.frame(Order,condition,vals)
data

ggplot(data, aes(fill=condition, y=vals, x=Order)) + 
  geom_bar(position="dodge", stat="identity") +
  scale_fill_manual(values = c("gray40", "gray60", "gray80")) +
  theme_minimal()
```

### 1.7.3

Рисунок 3

```{r 1.7.3}
mono2$typeXorder <- paste(mono2$type, mono2$order, sep=" ")
mono2

mono2 %>%
  ggplot(aes(x=order, y=RTlog, fill=order)) +
  geom_boxplot() +
  scale_fill_manual(values = c("gray40", "gray60", "gray80")) +
  theme_classic()
```

### 1.7.4

Рисунок 4

```{r 1.7.4}
mono2$inverseRT <- 10^(mono2$RTlog)

mono2 %>%
  ggplot(aes(x=order, y=inverseRT, fill=order)) +
  geom_boxplot() +
  scale_fill_manual(values = c("gray40", "gray60", "gray80")) +
  theme_classic()
```

### 1.7.5

Рисунок 5

```{r 1.7.5}

```

### 1.7.6

Рисунок 6

```{r 1.7.6}

```

### 1.7.7

Рисунок 7

```{r 1.7.7}

```


### 1.8

T-test. Проанализируйте разницу в среднем значении RTlog, сгруппировав данные по порядку слов в стимуле (конгруэнтный vs неконгруэнтный). Сформулируйте нулевую и альтернативную гипотезу, аргументируйте, какой тип t-test'а следует применить, сделайте статистический и содержательный вывод о значимости различия.  

```
YOU TEXT HERE
```

```{r 1.8}
#YOU CODE HERE
```

### 1.9

ANOVA. Проанализируйте разницу в среднем значении RTlog, сгруппировав данные по трем условиям 
(прилагательное размера > прилагательное национальности, прилагательное цвета > прилагательное формы, прилагательное субъективного комментария > прилагательное материала) и по участнику. Сформулируйте нулевую и альтернативную гипотезу, аргументируйте, какой тип дисперсионного анализа следует применить, сделайте статистический и содержательный вывод о значимости различия. Это задание выполняется только для ответов при порядке слов Incongruent.  

```
YOU TEXT HERE
```

```{r 1.9}
#YOU CODE HERE
```

### 1.10  

Post-hoc тест. Примените TukeyHSD тест, чтобы выяснить, какие конкретно пары условий TypeOfStimuli отличаются друг от друга по среднему значению RTlog.  
Это задание, аналогично, выполняется только для ответов при порядке слов Incongruent.  

```{r 1.10}
#YOU CODE HERE
```

Запишите ниже интерпретацию post-hoc теста.  

```


```

## 2. Тест хи-квадрат и его аналоги (ваши данные)  

Найдите в публичных репозиториях (OSF, kaggle, Trolling, https://datasetsearch.research.google.com и т. д.) или возьмите ваши собственные данные, подходящие для проведения теста на (не)зависимость двух номинальных переменных. Данные должны быть лингвистическими, личные данные могут быть из курсовой, диплома, экспедиций, ваших исследовательских проектов и т. п. Вы можете модифицировать как общедоступные чужие, так и собственные данные.  

### 2.1 

Сформулируйте нулевую и альтернативную гипотезы

```

```

### 2.2 

Выложите файл с данными в свой репозиторий/облако. Прочитайте данные, дав на них ссылку URL. Постройте таблицу сопряженности.   

```{r 2.2}

```

### 2.3

Проведите анализ, аргументировав выбор статистического теста. Сформулируйте статистический и содержательный вывод о значимости. Проведите анализ величины эффекта (если необходимо). Проведите post-hoc тест(ы) (если необходимо).

```
YOUR TEXT HERE
```


```{r 2.3}
#YOU CODE HERE
```
